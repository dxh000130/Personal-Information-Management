<!DOCTYPE html>
<html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<head>
	<title>CubicleSoft File Explorer Demo</title>
</head>

<body>
	<style type="text/css">
		li{
			font-size: 120%;
			margin:15% auto;
		}
		body {
			font-family: Verdana, Arial, Helvetica, sans-serif;
			position: relative;
			color: #222222;
			font-size: 1.0em;
			border:rgb(42, 123, 177)
		}

		html.embed,
		html.embed body {
			padding: 0;
			margin: 0;
		}

		html.embed p {
			padding: 0;
			margin: 0;
			display: none;
		}

		#filemanager {
			height: 96vh;
			position: relative;
		}

		html.embed #filemanager {
			height: 96vh;
		}
		/* Tag */
		.fe_fileexplorer_tag_tool {
			background: url(./artwork/biaoqian.svg) no-repeat center/80%
		}

		.tag-contained {
			background: url(./artwork/fileexplorer_checkbox.svg) no-repeat center/80%
		}

		.tag-list {
			margin: 0;
			min-width: 120px;
			border-right: 1px gray solid;
		}

		.fe_fileexplorer_items_scroll_wrap {
			display: flex;
		}

		.fe_fileexplorer_items_scroll_wrap_inner {
			flex-grow: 1;
		}
		/* The Modal (background) */
		.modal {
			display: none;
			/* Hidden by default */
			position: fixed;
			/* Stay in place */
			z-index: 1;
			/* Sit on top */
			left: 0;
			top: 0;
			width: 100%;
			/* Full width */
			height: 100%;
			/* Full height */
			overflow: auto;
			/* Enable scroll if needed */
			background-color: rgb(0, 0, 0);
			/* Fallback color */
			background-color: rgba(0, 0, 0, 0.4);
			/* Black w/ opacity */
		}

		/* Modal Content/Box */
		.modal-content {
			background-color: #fefefe;
			margin: 15% auto;
			/* 15% from the top and centered */
			padding: 20px;
			border: 2px solid rgb(34, 85, 180);
			border-radius: 6px;
			width: 50%;
		}
		
		.btnStyle {
			padding: .3em .8em;
			border: 1px solid #888;
			/*background: #58a linear-gradient(#77a0bb,#58a);*/
			background: linear-gradient(hsla(0,0%,100%,.2),transparent);
			border-radius: .2em;
			/*box-shadow: 0 .05em .25em gray;*/
			color: rgb(122, 122, 122);
			font-size: 125%;
			line-height: 1.5;
			transition: .3s;
			width: 25vw;
		}
		
		.btnStyle:hover{
		color: var(--primary-color);
		border-color: currentColor;
		background-color: var(--primary-background-color);
		}
	

		/* The Close Button */
		.close {
			color: #aaa;
			float: right;
			font-size: 35px;
			font-weight: bold;
		}

		.close:hover,
		.close:focus {
			color: black;
			text-decoration: none;
			cursor: pointer;
		}

		.inputStyle{
			margin: 2vh; 
			width: 25vw;
			padding: 10px 0px;
			font-size: 125%;
			border-top-width: 0px;
 			border-right-width: 0px;
			border-bottom-width: 1px;
 			border-left-width: 0px;
			outline: none;
			text-align: center;
		}

		.inputStyle:hover{
			border-color: var(--primary-color);
		}

		.inputStyle:focus{
			border-color: var(--primary-color);
		}

		.fe_fileexplorer_statusbar_text_segment_wrap{
			height: 30px;
			font-size:125%;
		}

		.fe_fileexplorer_statusbar_text_segment_wrap:focus{
			background-color: var(--primary-color);
		}
		
		:root{
  		--primary-color: rgb(34, 85, 180);
		--primary-background-color:rgb(213, 232, 245);
		}

	</style>

	<link rel="stylesheet" type="text/css" href="file-explorer/file-explorer.css">
	<script type="text/javascript" src="file-explorer/file-explorer.js"></script>

	<div id="filemanager">
		<div id="annotation-input-modal" class="modal">
			<!-- Modal content -->
			<div class="modal-content">
				<span class="close">&times;</span>
				<div style="display:flex; flex-direction:column; align-items: center; justify-content: center;">
					<p style = "font-size:125%;color:#888">File Annotation </p>
					<input class = "inputStyle" type="text" id="annotation-input" />
					<button class = "btnStyle" id="annotation-input-submit">Save</button>
				</div>
			</div>

		</div>
	</div>


	<script type="text/javascript">
		// Math.seed = 5;
		// Math.seededrandom = function (){
		// 	var max = 4294967296; // 2^32
		// 	seed = 49734321;
		// 	seed = (seed * 9301 + 49297) % max;
		// 	return seed / max;
		// }
		
		var span = document.getElementsByClassName("close")[0];
		span.onclick = function () {
			var modal = document.getElementById("annotation-input-modal");
			span.onclick = function () {
				console.log("close");
				modal.style.display = "none";
			};
		};
		(function () {
			// Handle iframe demo embed.
			if (window.location.href.indexOf('embed=true') > -1) document.documentElement.classList.add('embed');

			// Back to regularly scheduled program.
			var elem = document.getElementById('filemanager');

	const fileTree = {
		'/': {
			children: {
				'folder1': {
					children: {
						'file1.txt': { },
						'file2.txt': { },
						'file3.txt': { },
						'file4.txt': { },
						'file5.txt': { },
						'folder11': { 
							children: {},
						},
						'folder12': {
							 children: {
								'file11': {  },
								'file12': {  },
								'file13': {  },
							}
						},
						'folder13': { 
							children: {},
						},
					},
				},
				'folder2': { 
					children: {
						'file22.txt': { },
						'file23.txt': { },
					}
				},
				'folder3': {
					children: {},
				},
			},
		}
	};

	let id = 0;
	const idMap = {};
	(function walkTree(node, name)  {
		const { children = {} } = node;
		node.id = String(id++);
		node.name = name
		idMap[node.id] = node;

		for (const childName of Object.keys(children)) {
			walkTree(children[childName], childName)
		}
	})(fileTree['/'])

	const allTags = {
		Tag1: new Set(),
		Tag2: new Set(),
		Tag3: new Set(),
		Tag4: new Set(),
	};
	const tagList = document.createElement('ul');


	const tagTool = function(fe) {
		const node = fe.AddToolbarButton('fe_fileexplorer_tag_tool', fe.Translate('Tag'));
		node.addEventListener('click', () => {
			if (node.classList.contains('fe_fileexplorer_disabled')) {
				return;	
			}

			const selectedIds = fe.GetSelectedItemIDs();
			const inputEl = document.createElement('input');

			const popup = new window.FileExplorer.PopupMenu(node, {
				items: [{id: 'add', name: 'Add Tag'},  'split', ...Object.keys(allTags).map(tag => ({ id: tag, name: tag, ...(allTags[tag].has(selectedIds[0]) ? { icon: 'tag-contained' } : null) }))],
				oncancel: () => {
					popup.Destroy()
				},
				onselected: (tag) => {
					const selectedIds = fe.GetSelectedItemIDs();
					const itemId = selectedIds[0];

					if (tag === 'add') {
						popup.Destroy();
						setTimeout(() => {
							const tag = window.prompt('Input New Tag');
							allTags[tag] = new Set([itemId])
						}, 0)
					} else {
						allTags[tag].has(itemId) ? allTags[tag].delete(itemId) : allTags[tag].add(itemId);
						popup.Destroy();
					}

				},
				onposition: (popupEl) => {
					popupEl.style.position = 'fixed';
					popupEl.style.left = `${node.clientWidth}px`;
					popupEl.style.zIndex = '1000';
				},
			});

		});

		fe.addEventListener('update_tool', (currfolder, attrs) => {
			const selectedIds = fe.GetSelectedItemIDs();
			const enabled = !currfolder.waiting && selectedIds.length === 1 && (!('canmodify' in attrs) || attrs.canmodify) && !idMap[selectedIds[0]].children;

			if (enabled) {
				node.classList.remove('fe_fileexplorer_disabled')
			} else {
				node.classList.add('fe_fileexplorer_disabled');
			}

			fe.ToolStateUpdated();
		});

	};
	window.FileExplorer.RegisterTool(2, tagTool);

	var options = {
		// This allows drag-and-drop and cut/copy/paste to work between windows of the live demo.
		// Your application should either define the group uniquely for your application or not at all.
		group: 'demo_test_group',

		capturebrowser: true,

		initpath: [
			[ '/', '/' ],
		],

		onfocus: function(e) {
console.log('focus');
console.log(e);
		},

		onblur: function(e) {
console.log('blur');
console.log(e);
		},

		// See main documentation for the complete list of keys.
		// The only tool that won't show as a result of a handler being defined is 'item_checkboxes'.
		tools: {
			item_checkboxes: true
		},

		onrefresh: function(folder, required) {
			var newentries = [];
			const ids = folder.GetPathIDs();
			const firstId = ids[0];

			if (firstId === 'HFO View') {
				document.getElementsByClassName('fe_fileexplorer_items_scroll_wrap')[0].style.display='';
				let dir = fileTree['/'];
			}
			if (firstId === 'Tag View') {
				document.getElementsByClassName('fe_fileexplorer_items_scroll_wrap')[0].style.display='';
				const folder = fe.GetCurrentFolder();
				folder.SetEntries([]);

				const containerEl = fe.GetElements()['itemsscrollwrap'];
				tagList.classList.add('tag-list');

				for (const tag of Object.keys(allTags)) {
					const li = document.createElement('li');
					li.textContent = tag;
					li.dataset.tag = tag;
					tagList.append(li);
				}

				containerEl.prepend(tagList);
				return;
			}
			if (firstId === 'Tree Visualization') {
				document.getElementsByClassName('fe_fileexplorer_items_scroll_wrap')[0].style.display='none';

			}
			tagList.remove();
			tagList.innerHTML = '';
			let dir = fileTree['/'];

			for (const p of ids.slice(1)) {
				dir = idMap[p];

				if (!dir) {
					throw new Error(`no such dir: ${ids.join('/')}`);
				}
			}

			if (!dir.children) {
				throw new Error(`${ids.join('/')} is not a dir`);
			}

			folder.SetEntries(Object.values(dir.children).map(item => ({
				id: item.id,
				name: item.name, 
				type: item.children ? 'folder': 'file',
			})))
			var xhr = new this.PrepareXHR({
				url: "http://www.dxh000130.top/filemanager/",
				params: {
					action: 'file_explorer_refresh',
					path: JSON.stringify(folder.GetPathIDs()),
					xsrftoken: 'asdfasdf'
				},
				onsuccess: function(e) {
					console.log(e)
					var data = JSON.parse(e.target.responseText);
					console.log(data);

					if (data.success)
					{
						if ($this.IsMappedFolder(folder))  folder.SetEntries(data.entries);
					}
					else if (required)
					{
						$this.SetNamedStatusBarText('folder', $this.EscapeHTML('Failed to load folder.  ' + data.error));
					}
				},
				onerror: function(e) {
					// Maybe output a nice message if the request fails for some reason.
//					if (required)  $this.SetNamedStatusBarText('folder', 'Failed to load folder.  Server error.');

					console.log(e);
				}
			});

			xhr.Send();
		},

		onrename: function(renamed, folder, entry, newname) {
			// Simulate network delay.
			setTimeout(function() {
				// The entry is a copy of the original, so it is okay to modify any aspect of it, including id.
				// Passing in a completely new entry to the renamed() callback is also okay.
				entry.id = newname;
				entry.name = newname;

				renamed(entry);
			}, 250);
		},

		onopenfile: function(folder, entry) {
console.log(entry);
		},

		onnewfolder: function(created, folder) {
			// Simulate network delay.
			setTimeout(function() {
				var entry = { name: 'New Folder', type: 'folder', id: 'asdfasdffolder123', hash: 'asdfasdffolder123' };

				created(entry);
			}, 250);
		},

		onnewfile: function(created, folder) {
			// Simulate network delay.
			setTimeout(function() {
				var entry = { name: 'New File.txt', type: 'file', id: 'asdfasdffile123', hash: 'asdfasdffile123' };

				created(entry);
			}, 250);
		},

		oninitupload: function(startupload, fileinfo) {
console.log(fileinfo.file);
console.log(JSON.stringify(fileinfo.folder.GetPathIDs()));

			if (fileinfo.type === 'dir')
			{
				// Create a directory.  This type only shows up if the directory is empty.

				// Simulate network delay.
				setTimeout(function() {

					// Passing false as the second parameter to startupload will remove the item from the queue.
					startupload(false);
				}, 250);
			}
			else
			{
				// Simulate network delay.
				setTimeout(function() {
					// Set a URL, headers, and params to send with the file data to the server.
					fileinfo.url = 'filemanager/';

					fileinfo.headers = {
					};

					fileinfo.params = {
						action: 'upload',
						id: 'temp-12345',
						path: JSON.stringify(fileinfo.folder.GetPathIDs()),
						name: fileinfo.fullPath,
						size: fileinfo.file.size,
						xsrftoken: 'asdfasdf'
					};

					fileinfo.fileparam = 'file';

					// Optional:  Send chunked uploads.  Requires the server to know how to put chunks back together.
					fileinfo.chunksize = 1000000;

					// Optional:  Automatic retry count for the file on failure.
					fileinfo.retries = 3;

					// Start the upload.
					startupload(true);
				}, 250);
			}
		},

		// Optional upload handler function to finalize an uploaded file on a server (e.g. move from a temporary directory to the final location).
		onfinishedupload: function(finalize, fileinfo) {
console.log(fileinfo);
			// Simulate network delay.
			setTimeout(function() {
				finalize(true);
			}, 250);
		},

		// Optional upload handler function to receive permanent error notifications.
		onuploaderror: function(fileinfo, e) {
console.log(e);
console.log(fileinfo);
		},

		oninitdownload: function(startdownload, folder, ids, entries) {
			// Simulate network delay.
			setTimeout(function() {
				// Set a URL and params to send with the request to the server.
				var options = {};

				// Optional:  HTTP method to use.
//				options.method = 'POST';

				options.url = 'filemanager/';

				options.params = {
					action: 'download',
					path: JSON.stringify(folder.GetPathIDs()),
					ids: JSON.stringify(ids),
					xsrftoken: 'asdfasdf'
				};

				// Optional:  Control the download via an in-page iframe (default) vs. form only (new tab).
//				options.iframe = false;

				startdownload(options);
			}, 250);
		},

		ondownloadstarted: function(options) {
console.log('started');
console.log(options);
		},

		ondownloaderror: function(options) {
console.log('error');
console.log(options);
		},

		// Calculated information must be fully synchronous (i.e. no AJAX calls).  Chromium only.
		ondownloadurl: function(result, folder, ids, entry) {
			result.name = (ids.length === 1 ? (entry.type === 'file' ? entry.name : entry.name + '.zip') : 'download-' + Date.now() + '.zip');
			result.url = 'http://127.0.0.1/filemanager/?action=download&xsrfdata=asdfasdfasdf&xsrftoken=asdfasdf&path=' + encodeURIComponent(JSON.stringify(folder.GetPathIDs())) + '&ids=' + encodeURIComponent(JSON.stringify(ids));
		},

		oncopy: function(copied, srcpath, srcids, destfolder) {
			// Simulate network delay.
			setTimeout(function() {
				// Fill an array with copied destination folder entries from the server.
				var entries = [];

				copied(true, entries);
			}, 250);
		},

		onmove: function(moved, srcpath, srcids, destfolder) {
			// Simulate network delay.
			setTimeout(function() {
				// Fill an array with moved destination folder entries from the server.
				var entries = [];

				moved(true, entries);
			}, 250);
		},

		ondelete: function(deleted, folder, ids, entries, recycle) {
			// Ask the user if they really want to delete/recycle the items.
			const confirmation = confirm('Are you sure you want to permanently delete ' + (entries.length == 1 ? '"' + entries[0].name + '"' : entries.length + ' items') +  '?')
			if (!recycle && !confirmation)  deleted('Cancelled deletion');
			else
			{
				// Simulate network delay.
				setTimeout(function() {
					deleted(true);
				}, 250);
			}
		},
	};

	var fe = new window.FileExplorer(elem, options);

	tagList.addEventListener('click', (e) => {
		const tag = e.target.dataset.tag;
		const folder = fe.GetCurrentFolder();

		folder.SetEntries(Array.from(allTags[tag]).map(itemId => ({
			id: itemId,
			name: idMap[itemId].name,
			type: idMap[itemId].children ? 'folder' : 'file',
		})));
	});


	let previousDir;
	fe.SetNamedStatusBarText('toggleHFOView', 'HFO View', null, () => {
		const currentDir = fe.GetCurrentFolder().GetPath();

		if (currentDir[0][0] === 'HFO View') {
			fe.SetPath(previousDir)
		} else {
			previousDir = fe.GetCurrentFolder().GetPath();
			fe.SetPath([['HFO View', 'HFO View', { canmodify: true }]])
		}

	});
	fe.SetNamedStatusBarText('toggleTagView', 'Tag View', null, () => {
		const currentDir = fe.GetCurrentFolder().GetPath();

		if (currentDir[0][0] === 'Tag View') {
			fe.SetPath(previousDir)
		} else {
			previousDir = fe.GetCurrentFolder().GetPath();
			fe.SetPath([['Tag View', 'Tag View', { canmodify: true }]])
		}

	});
	fe.SetNamedStatusBarText('toggleTreeView', 'Tree Visualization', null, () => {
		const currentDir = fe.GetCurrentFolder().GetPath();

		if (currentDir[0][0] === 'Tree Visualization') {
			fe.SetPath(previousDir)
		} else {
			previousDir = fe.GetCurrentFolder().GetPath();
			fe.SetPath([['Tree Visualization', 'Tree Visualization', { canmodify: false }]])
		}

	});

//fe.Focus();

	// Verify that there aren't any leaked globals.
	setTimeout(function() {
		// Create an iframe and put it in the <body>.
		var iframe = document.createElement('iframe');
		document.body.appendChild(iframe);

		// We'll use this to get a "pristine" window object.
		var pristineWindow = iframe.contentWindow.window;

		// Go through every property on `window` and filter it out if
		// the iframe's `window` also has it.
		console.log(Object.keys(window).filter(function(key) {
			return !pristineWindow.hasOwnProperty(key)
		}));

		// Remove the iframe.
		document.body.removeChild(iframe)
	}, 15000);

/*
	// Test destroy.
	setTimeout(function() {
		fe.Destroy();
	}, 20000);
*/
})();
</script>


</body>

</html>