<!DOCTYPE html>
<html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<head>
	<title>CubicleSoft File Explorer Demo</title>
</head>

<body>
	<style type="text/css">
		li {
			font-size: 120%;
			margin: 15% auto;
		}

		body {
			font-family: Verdana, Arial, Helvetica, sans-serif;
			position: relative;
			color: #222222;
			font-size: 1.0em;
			border: rgb(42, 123, 177)
		}

		html.embed,
		html.embed body {
			padding: 0;
			margin: 0;
		}

		html.embed p {
			padding: 0;
			margin: 0;
			display: none;
		}

		#filemanager {
			height: 96vh;
			position: relative;
		}

		html.embed #filemanager {
			height: 96vh;
		}

		/* Tag */
		.fe_fileexplorer_tag_tool {
			background: url(./artwork/biaoqian.svg) no-repeat center/80%
		}

		.tag-contained {
			background: url(./artwork/fileexplorer_checkbox.svg) no-repeat center/80%
		}

		.tag-list {
			margin: 0;
			min-width: 120px;
			border-right: 1px gray solid;
		}

		.fe_fileexplorer_items_scroll_wrap {
			display: flex;
		}

		.fe_fileexplorer_items_scroll_wrap_inner {
			flex-grow: 1;
		}

		/* The Modal (background) */
		.modal {
			display: none;
			/* Hidden by default */
			position: fixed;
			/* Stay in place */
			z-index: 1;
			/* Sit on top */
			left: 0;
			top: 0;
			width: 100%;
			/* Full width */
			height: 100%;
			/* Full height */
			overflow: auto;
			/* Enable scroll if needed */
			background-color: rgb(0, 0, 0);
			/* Fallback color */
			background-color: rgba(0, 0, 0, 0.4);
			/* Black w/ opacity */
		}

		/* Modal Content/Box */
		.modal-content {
			background-color: #fefefe;
			margin: 15% auto;
			/* 15% from the top and centered */
			padding: 20px;
			border: 2px solid rgb(34, 85, 180);
			border-radius: 6px;
			width: 50%;
		}

		.btnStyle {
			padding: .3em .8em;
			border: 1px solid #888;
			/*background: #58a linear-gradient(#77a0bb,#58a);*/
			background: linear-gradient(hsla(0, 0%, 100%, .2), transparent);
			border-radius: .2em;
			/*box-shadow: 0 .05em .25em gray;*/
			color: rgb(122, 122, 122);
			font-size: 125%;
			line-height: 1.5;
			transition: .3s;
			width: 25vw;
		}

		.btnStyle:hover {
			color: var(--primary-color);
			border-color: currentColor;
			background-color: var(--primary-background-color);
		}


		/* The Close Button */
		.close {
			color: #aaa;
			float: right;
			font-size: 35px;
			font-weight: bold;
		}

		.close:hover,
		.close:focus {
			color: black;
			text-decoration: none;
			cursor: pointer;
		}

		.inputStyle {
			margin: 2vh;
			width: 25vw;
			padding: 10px 0px;
			font-size: 125%;
			border-top-width: 0px;
			border-right-width: 0px;
			border-bottom-width: 1px;
			border-left-width: 0px;
			outline: none;
			text-align: center;
		}

		.inputStyle:hover {
			border-color: var(--primary-color);
		}

		.inputStyle:focus {
			border-color: var(--primary-color);
		}

		.fe_fileexplorer_statusbar_text_segment_wrap {
			height: 30px;
			font-size: 125%;
		}

		.fe_fileexplorer_statusbar_text_segment_wrap:focus {
			background-color: var(--primary-color);
		}

		:root {
			--primary-color: rgb(34, 85, 180);
			--primary-background-color: rgb(213, 232, 245);
		}

		.treeview {
			display: inline-block;
			width: 260px;
			height: 480px;
			border: 1px solid gray;
			position: absolute;
			right: 0;
			bottom: 0;
			z-index: 100;
		}

		.treeview .top {
			border-bottom: 1px solid gray;
			padding: 10px;
		}

		.tree {
			flex: 1;
			overflow: auto;
			padding: 4px 0;
			position: relative;
			width: 100%;
			height: 430px;
		}

		.tree summary {
			outline: 0;
			padding-left: 20px;
			list-style: none;
			/* display: -webkit-box;
    -webkit-line-clamp: 1;
    -webkit-box-orient: vertical;
    overflow: hidden; */
		}

		.tree summary:not(:only-child) {
			background: url("data:image/svg+xml,%3Csvg width='12' height='12' viewBox='0 0 12 12' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M5.354 2.646A.5.5 0 0 0 4.5 3v6a.5.5 0 0 0 .854.354l3-3a.5.5 0 0 0 0-.708l-3-3z' fill='%23000' fill-opacity='.45'/%3E%3C/svg%3E") 4px center no-repeat;
		}

		.tree details[open]>summary:not(:only-child) {
			background-image: url("data:image/svg+xml,%3Csvg width='12' height='12' viewBox='0 0 12 12' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M9.354 5.354A.5.5 0 0 0 9 4.5H3a.5.5 0 0 0-.354.854l3 3a.5.5 0 0 0 .708 0l3-3z' fill='%23000' fill-opacity='.45'/%3E%3C/svg%3E");
		}

		.tree details {
			padding-left: 10px
		}

		.tree-item {
			display: flex;
			align-items: center;
			height: 46px;
			font-size: 15px;
			line-height: 22px;
			color: rgba(0, 0, 0, 0.85);
			padding-left: 400px;
			margin-left: -400px;
			cursor: default;
		}

		.tree-item::after {
			content: '';
			position: absolute;
			left: 10px;
			right: 10px;
			height: 38px;
			background: #EEF2FF;
			border-radius: 8px;
			z-index: -1;
			opacity: 0;
			transition: .2s;
		}

		.tree-item:hover::after {
			opacity: 1;
		}

		.tree-item::before {
			content: '';
			width: 20px;
			height: 20px;
			flex-shrink: 0;
			margin-right: 8px;
			background: url("data:image/svg+xml,%3Csvg width='20' height='20' viewBox='0 0 20 20' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M.833 3.75c0-.92.746-1.667 1.667-1.667h5.417c.247 0 .481.11.64.3l1.833 2.2h7.11c.92 0 1.667.747 1.667 1.667v10c0 .92-.747 1.667-1.667 1.667h-15c-.92 0-1.667-.746-1.667-1.667V3.75zm6.693 0H2.5v4.584h15V6.25H10a.833.833 0 0 1-.64-.3l-1.834-2.2zM17.5 10h-15v6.25h15V10z' fill='%23000' fill-opacity='.45'/%3E%3C/svg%3E") center no-repeat;
		}

		.tree details[open]>summary:not(:only-child)>.tree-item::before {
			background-image: url("data:image/svg+xml,%3Csvg width='20' height='20' viewBox='0 0 20 20' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M7.917 2.083c.247 0 .481.11.64.3l1.833 2.2h5.443c.92 0 1.667.747 1.667 1.667v1.667h.833a.833.833 0 0 1 .817.997l-1.666 8.333a.833.833 0 0 1-.817.67H1.677a.814.814 0 0 1-.157-.013.83.83 0 0 1-.687-.82V3.75c0-.92.746-1.667 1.667-1.667h5.417zM10 6.25a.833.833 0 0 1-.64-.3l-1.834-2.2H2.5v6.564l.441-1.766a.833.833 0 0 1 .809-.631h12.083V6.25H10zm-7.266 10L4.4 9.584h12.916l-1.334 6.666H2.733z' fill='%23000' fill-opacity='.45'/%3E%3C/svg%3E");
		}

		.file-item::before {
			content: '';
			width: 20px;
			height: 20px;
			flex-shrink: 0;
			margin-right: 8px;
			background-size: 100%;
			background-image: url("./artwork/navigation/file-icon.png");
		}
	</style>

	<link rel="stylesheet" type="text/css" href="file-explorer/file-explorer.css">
	<script type="text/javascript" src="file-explorer/file-explorer.js"></script>

	<div id="filemanager">

		<div class="treeview">
			<div class="top">Navigation</div>
			<div class="tree" id="tree">

			</div>
		</div>

		<div id="annotation-input-modal" class="modal">
			<!-- Modal content -->
			<div class="modal-content">
				<span class="close">&times;</span>
				<div id="FileTree121"></div>
				<div style="display:flex; flex-direction:column; align-items: center; justify-content: center;">
					<p style="font-size:125%;color:#888">File Annotation </p>
					<input class="inputStyle" type="text" id="annotation-input" />
					<button class="btnStyle" id="annotation-input-submit">Save</button>
				</div>
			</div>

		</div>
	</div>


	<script type="text/javascript">
		window.globalConfig = {
			fileTree: {
				'/': {
					children: {
					},
				}
			},
		}

		function gen_tree(childs) {
			var html = ''
			for (let child in childs) {
				//console.log(child)
				if (childs[child].type == 'folder') {
					html += `<details>
    <summary>
       <span class="tree-item"  title="${child}" data-id="${child}">${child}</span>
    </summary>`
				} else {
					html += `<details>
    <summary>
       <span class="tree-item file-item"  title="${child}" data-id="${child}">${child}</span>
    </summary>`
				}
				if (childs[child].children) {
					//console.log('sucess');
					html += gen_tree(childs[child].children) // 如果有chidren就继续遍历
				}
				html += `</details>`
			}

			return html;
		}

		// StoreAnnotatesButton.onclick = function () {
		// 	localStorage.setItem(FilePath, document.getElementById("annotation-input").value);
		//
		// 	const folder = fe.GetCurrentFolder();
		// 	folder.SetEntries([]);
		// 	fe.settings.onrefresh(fe.GetCurrentFolder(), "");
		// 	document.getElementById("annotation-input-modal").style.display = 'none'
		//
		// }
		var span = document.getElementsByClassName("close")[0];
		span.onclick = function () {
			var modal = document.getElementById("annotation-input-modal");
			span.onclick = function () {
				console.log("close");
				modal.style.display = "none";
			};
		};
		(function () {
			// Handle iframe demo embed.
			if (window.location.href.indexOf('embed=true') > -1) document.documentElement.classList.add('embed');

			// Back to regularly scheduled program.
			var elem = document.getElementById('filemanager');

			Main1(window.globalConfig.fileTree, elem)

		})();

		function Main1(fileTree, elem) {
			var triggers = {}
			var $this = this;
			var defaults = {
				messagetimeout: 2000,

				fileexplorer: null,
				fe_group: null,
				fe_capturebrowser: true,
				fe_initpath: [
					['', '/']
				],
				fe_displayunits: 'iec_windows',
				fe_adjustprecision: true,
				fe_refreshall: true,
				fe_requestvar: 'action',
				fe_requestprefix: 'file_explorer_',
				fe_uploadchunksize: 0,
				fe_concurrentuploads: 4,

				fe_tools: {},

				fe_downloadiframe: true,

				ace_modes: [],
				ace_themes: [],

				recycling: true,
				tabbed: true,

				onxhrparams: null,

				langmap: {}
			};
			$this.settings = Object.assign({}, defaults, options);
			var DispatchEvent = function (eventname, params) {
				if (!triggers[eventname]) return;

				triggers[eventname].forEach(function (callback) {
					if (Array.isArray(params)) callback.apply($this, params);
					else callback.call($this, params);
				});
			};
			let id = 0;
			const idMap = {};
			(function walkTree(node, name) {
				const { children = {} } = node;
				idMap[node.id] = node;

				for (const childName of Object.keys(children)) {
					//console.log("debug", childName)
					walkTree(children[childName], childName)
				}
			})(fileTree['/'])

			const allTags = {
				Tag1: new Set(),
				Tag2: new Set(),
				Tag3: new Set(),
				Tag4: new Set(),
			};
			const tagList = document.createElement('ul');


			const tagTool = function (fe) {
				const node = fe.AddToolbarButton('fe_fileexplorer_tag_tool', fe.Translate('Tag'));
				node.addEventListener('click', () => {
					if (node.classList.contains('fe_fileexplorer_disabled')) {
						return;
					}

					const selectedIds = fe.GetSelectedItemIDs();
					const inputEl = document.createElement('input');

					const popup = new window.FileExplorer.PopupMenu(node, {
						items: [{ id: 'add', name: 'Add Tag' }, 'split', ...Object.keys(allTags).map(tag => ({ id: tag, name: tag, ...(allTags[tag].has(selectedIds[0]) ? { icon: 'tag-contained' } : null) }))],
						oncancel: () => {
							popup.Destroy()
						},
						onselected: (tag) => {
							const selectedIds = fe.GetSelectedItemIDs();
							const itemId = selectedIds[0];

							if (tag === 'add') {
								popup.Destroy();
								setTimeout(() => {
									const tag = window.prompt('Input New Tag');
									allTags[tag] = new Set([itemId])
								}, 0)
							} else {
								allTags[tag].has(itemId) ? allTags[tag].delete(itemId) : allTags[tag].add(itemId);
								popup.Destroy();
							}

						},
						onposition: (popupEl) => {
							popupEl.style.position = 'fixed';
							popupEl.style.left = `${node.clientWidth}px`;
							popupEl.style.zIndex = '1000';
						},
					});

				});

				fe.addEventListener('update_tool', (currfolder, attrs) => {
					const selectedIds = fe.GetSelectedItemIDs();
					const enabled = !currfolder.waiting && selectedIds.length === 1 && (!('canmodify' in attrs) || attrs.canmodify) && !idMap[selectedIds[0]].children;

					if (enabled) {
						node.classList.remove('fe_fileexplorer_disabled')
					} else {
						node.classList.add('fe_fileexplorer_disabled');
					}

					fe.ToolStateUpdated();
				});

			};
			window.FileExplorer.RegisterTool(2, tagTool);

			var options = {
				// This allows drag-and-drop and cut/copy/paste to work between windows of the live demo.
				// Your application should either define the group uniquely for your application or not at all.
				group: 'demo_test_group',

				capturebrowser: true,

				initpath: [
					['/', '/'],
				],

				onfocus: function (e) {
					console.log('focus');
					console.log(e);
				},

				onblur: function (e) {
					console.log('blur');
					console.log(e);
				},

				// See main documentation for the complete list of keys.
				// The only tool that won't show as a result of a handler being defined is 'item_checkboxes'.
				tools: {
					item_checkboxes: true
				},

				onrefresh: function (folder, required) {

					const filejson = {
						'/': {
						},
					};
					AddFilesFromServer(this, fileTree["/"].children, ["/"], filejson["/"]);
					setTimeout(function (folder, required) {

						console.log('tree', fileTree['/'].children);
						let html = gen_tree(fileTree['/'].children);
						SearchResult = function (childs, resultarray) {
							var input = document.getElementsByClassName("fe_fileexplorer_searchbar")[0].value;
							for (let child in childs) {
								//console.log(childs[child])
								if (childs[child].name.search(input) !== -1){
									console.log(child)
									resultarray.push(childs[child].id)
								}
								if (childs[child].children) {
									//console.log('sucess');
									SearchResult(childs[child].children, resultarray) // 如果有chidren就继续遍历
								}

							}
						}
						document.getElementById('tree').innerHTML = html;
						//console.log(html);
						//console.log(filejson);

						//FileJsonFromFileTree(fileTree, filejson);
						(function walkTree(node, name) {
							const { children = {} } = node;
							//node.id = String(id++);
							//node.name = name
							idMap[node.id] = node;

							for (const childName of Object.keys(children)) {
								walkTree(children[childName], childName)
							}
						})(fileTree['/'])

						console.log("Onfresh被调用")
						var newentries = [];
						const ids = folder.GetPathIDs();
						const firstId = ids[0];

						var SearchInput = document.getElementsByClassName("fe_fileexplorer_searchbar")[0];
						SearchInput.oninput = function () {
							console.log("SearchInput", SearchInput.value)
							if (SearchInput.value !== ""){
								let resultarray = new Array();
								previousDir = fe.GetCurrentFolder().GetPath();
								const folder = fe.GetCurrentFolder();
								SearchResult(fileTree["/"].children, resultarray);
								console.log(resultarray);

								folder.SetEntries(Array.from(resultarray).map(itemId => ({
									id: itemId,
									name: idMap[itemId].name,
									type: idMap[itemId].children ? 'folder' : 'file',
									hash: idMap[itemId].hash,
									tooltip: idMap[itemId].tooltip + "\nLocation: " + itemId,
									size: idMap[itemId].size,
								})));
							}else {
								fe.SetPath(previousDir)
							}
						}


						if (firstId === 'HFO View') {
							document.getElementsByClassName('fe_fileexplorer_items_scroll_wrap')[0].style.display = '';
							let dir = fileTree['/'];
						}
						if (firstId === 'Tag View') {
							document.getElementsByClassName('fe_fileexplorer_items_scroll_wrap')[0].style.display = '';
							const folder = fe.GetCurrentFolder();
							folder.SetEntries([]);

							const containerEl = fe.GetElements()['itemsscrollwrap'];
							tagList.classList.add('tag-list');

							for (const tag of Object.keys(allTags)) {
								const li = document.createElement('li');
								li.textContent = tag;
								li.dataset.tag = tag;
								tagList.append(li);
							}

							containerEl.prepend(tagList);
							return;
						}
						if (firstId === 'Tree Visualization') {
							document.getElementsByClassName('fe_fileexplorer_items_scroll_wrap')[0].style.display = 'none';

						}
						tagList.remove();
						tagList.innerHTML = '';
						let dir = fileTree['/'];

						for (const p of ids.slice(1)) {
							dir = idMap[p];

							if (!dir) {
								throw new Error(`no such dir: ${ids.join('/')}`);
							}
						}

						if (!dir.children) {
							throw new Error(`${ids.join('/')} is not a dir`);
						}
						folder.SetEntries(Object.values(dir.children).map(item => ({
							id: item.id,
							name: item.name,
							type: item.children ? 'folder' : 'file',
							hash: item.hash,
							tooltip: item.tooltip,
							size: item.size,
						})))
					}, 1000, folder, required)

				},
				onrename: function (renamed, folder, entry, newname) {
					// Simulate network delay.
					var params = {
						path: JSON.stringify(folder.GetPathIDs()),
						id: entry.id,
						newname: newname
					};

					params[$this.settings.fe_requestvar] = $this.settings.fe_requestprefix + 'rename';

					DispatchEvent('xhr_params', [$this.settings.fe_requestprefix + 'rename', params]);

					var xhr = new this.PrepareXHR({
						url: 'http://www.dxh000130.top/filemanager/',
						params: params,
						onsuccess: function (e) {
							var data = JSON.parse(e.target.responseText);
							//console.log(data);

							if (data.success) renamed(data.entry);
							else renamed(data.error);
						},
						onerror: function (e) {
							console.log(e);
							renamed('Server/network error.');
						}
					});

					xhr.Send();
				},

				onopenfile: function (folder, entry) {
					console.log(entry);
				},

				onnewfolder: function (created, folder) {
					// Simulate network delay.
					var params = {
						path: JSON.stringify(folder.GetPathIDs())
					};

					params[$this.settings.fe_requestvar] = $this.settings.fe_requestprefix + 'new_folder';

					DispatchEvent('xhr_params', [$this.settings.fe_requestprefix + 'new_folder', params]);

					var xhr = new this.PrepareXHR({
						url: 'http://www.dxh000130.top/filemanager/',
						params: params,
						onsuccess: function (e) {
							var data = JSON.parse(e.target.responseText);
							//console.log(data);

							if (data.success) created(data.entry);
							else created(data.error);
						},
						onerror: function (e) {
							console.log(e);
							created('Server/network error.');
						}
					});

					xhr.Send();
				},

				onnewfile: function (created, folder) {
					// Simulate network delay.
					var params = {
						path: JSON.stringify(folder.GetPathIDs())
					};

					params[$this.settings.fe_requestvar] = $this.settings.fe_requestprefix + 'new_file';

					DispatchEvent('xhr_params', [$this.settings.fe_requestprefix + 'new_file', params]);

					var xhr = new this.PrepareXHR({
						url: 'http://www.dxh000130.top/filemanager/',
						params: params,
						onsuccess: function (e) {
							var data = JSON.parse(e.target.responseText);
							//console.log(data);

							if (data.success) created(data.entry);
							else created(data.error);
						},
						onerror: function (e) {
							console.log(e);
							created('Server/network error.');
						}
					});

					xhr.Send();
				},

				oninitupload: function (startupload, fileinfo, queuestarted) {
					console.log(fileinfo.file);
					console.log(JSON.stringify(fileinfo.folder.GetPathIDs()));

					var $this2 = this;

					if (fileinfo.type === 'dir') {
						// Create a directory.  This type only shows up if the directory is empty.
						// Set a URL, headers, and params to send to the server.
						fileinfo.url = 'http://www.dxh000130.top/filemanager/';

						fileinfo.headers = {
						};

						fileinfo.params = {
							path: JSON.stringify(fileinfo.folder.GetPathIDs()),
							name: fileinfo.fullPath
						};

						fileinfo.params[$this.settings.fe_requestvar] = $this.settings.fe_requestprefix + 'new_folder';

						DispatchEvent('xhr_params', [$this.settings.fe_requestprefix + 'new_folder', fileinfo.params]);

						fileinfo.currpathparam = 'currpath';

						// Automatic retry count for the directory on failure.
						fileinfo.retries = 3;

						// Create the directory.
						startupload(true);
					}
					else {
						var origcurrfolder = $this2.GetCurrentFolder();

						var initparams = {
							path: JSON.stringify(fileinfo.folder.GetPathIDs()),
							name: fileinfo.fullPath,
							size: fileinfo.file.size,
							currpath: JSON.stringify(origcurrfolder.GetPathIDs()),
							queuestarted: queuestarted
						};

						initparams[$this.settings.fe_requestvar] = $this.settings.fe_requestprefix + 'upload_init';

						DispatchEvent('xhr_params', [$this.settings.fe_requestprefix + 'upload_init', initparams]);
						console.log(initparams)
						// Prepare the file upload on the server.
						var xhr = new this.PrepareXHR({
							url: 'http://www.dxh000130.top/filemanager/',
							params: initparams,
							onsuccess: function (e) {
								var data = JSON.parse(e.target.responseText);
								//console.log(data);

								if (!data.success) startupload(data.error);
								else {
									if (data.entry && $this2.IsMappedFolder(origcurrfolder)) origcurrfolder.SetEntry(data.entry);

									// Set a URL, headers, and params to send with the file data to the server.
									fileinfo.url = 'http://www.dxh000130.top/filemanager/',

										fileinfo.headers = {
										};

									fileinfo.params = {
										path: JSON.stringify(fileinfo.folder.GetPathIDs()),
										name: fileinfo.fullPath,
										size: fileinfo.file.size,
										queuestarted: queuestarted
									};

									fileinfo.params[$this.settings.fe_requestvar] = $this.settings.fe_requestprefix + 'upload';

									DispatchEvent('xhr_params', [$this.settings.fe_requestprefix + 'upload', fileinfo.params]);

									fileinfo.fileparam = 'file';
									fileinfo.currpathparam = 'currpath';

									// Send chunked uploads.  Requires the server to know how to put chunks back together.
									if ($this.settings.fe_uploadchunksize) fileinfo.chunksize = $this.settings.fe_uploadchunksize;

									// Automatic retry count for the file on failure.
									fileinfo.retries = 3;

									// Start the upload.
									startupload(true);
								}
							},
							onerror: function (e) {
								console.log(e);
								startupload('Server/network error.');
							}
						});

						xhr.Send();
					}
				},
				concurrentuploads: $this.settings.fe_concurrentuploads,
				// Optional upload handler function to finalize an uploaded file on a server (e.g. move from a temporary directory to the final location).
				onfinishedupload: function (finalize, fileinfo) {
					console.log(fileinfo);
					// Simulate network delay.
					finalize(true);
					//location.reload();
				},

				// Optional upload handler function to receive permanent error notifications.
				onuploaderror: function (fileinfo, e) {
					console.log(e);
					console.log(fileinfo);
				},

				oninitdownload: function (startdownload, folder, ids, entries) {
					// Simulate network delay.
					setTimeout(function () {
						// Set a URL and params to send with the request to the server.
						var options = {};

						// Optional:  HTTP method to use.
						//				options.method = 'POST';

						options.url = 'http://www.dxh000130.top/filemanager/';

						options.params = {
							path: JSON.stringify(folder.GetPathIDs()),
							ids: JSON.stringify(ids)
						};

						options.params[$this.settings.fe_requestvar] = $this.settings.fe_requestprefix + 'download';

						DispatchEvent('xhr_params', [$this.settings.fe_requestprefix + 'download', options.params]);

						// Control the download via an in-page iframe (default) vs. form only (new tab).
						options.iframe = $this.settings.fe_downloadiframe;

						// Optional:  Control the download via an in-page iframe (default) vs. form only (new tab).
						//				options.iframe = false;

						startdownload(options);
					}, 250);
				},

				ondownloadstarted: function (options) {
					console.log('started');
					console.log(options);
				},

				ondownloaderror: function (options) {
					console.log('error');
					console.log(options);
				},

				// Calculated information must be fully synchronous (i.e. no AJAX calls).  Chromium only.
				ondownloadurl: function (result, folder, ids, entry) {
					result.name = (ids.length === 1 ? (entry.type === 'file' ? entry.name : entry.name + '.zip') : 'download-' + Date.now() + '.zip');
					result.url = 'http://www.dxh000130.top/filemanager/?action=download&xsrfdata=asdfasdfasdf&xsrftoken=asdfasdf&path=' + encodeURIComponent(JSON.stringify(folder.GetPathIDs())) + '&ids=' + encodeURIComponent(JSON.stringify(ids));
					console.log(result.url)
				},

				oncopy: function (copied, srcpath, srcids, destfolder) {
					// Simulate network delay.
					var $this2 = this;

					var initparams = {
						srcpath: JSON.stringify($this2.GetPathIDs(srcpath)),
						srcids: JSON.stringify(srcids),
						destpath: JSON.stringify(destfolder.GetPathIDs())
					};

					initparams[$this.settings.fe_requestvar] = $this.settings.fe_requestprefix + 'copy_init';

					DispatchEvent('xhr_params', [$this.settings.fe_requestprefix + 'copy_init', initparams]);

					var xhr = new this.PrepareXHR({
						url: 'http://www.dxh000130.top/filemanager/',
						params: initparams,
						onsuccess: function (e) {
							var data = JSON.parse(e.target.responseText);
							//console.log(data);

							if (!data.success) copied(data.error);
							else if (data.overwrite > 0 && !confirm($this2.FormatStr($this2.Translate('Copying will overwrite {0} ' + (data.overwrite === 1 ? 'item' : 'items') + '.  Proceed?'), data.overwrite))) copied('Copy cancelled.');
							else {
								var runxhr, origcurrfolder;

								var CancelXHR = function () {
									runxhr.Abort();
								};

								var progresstracker = $this2.CreateProgressTracker(CancelXHR);

								var options = {
									url: 'http://www.dxh000130.top/filemanager/',
									params: {
										copykey: data.copykey
									},
									onsuccess: function (e) {
										var data = JSON.parse(e.target.responseText);
										//console.log(data);

										if (!data.success) copied(data.error, data.finalentries);
										else {
											progresstracker.totalbytes = data.totalbytes;
											progresstracker.queueditems = data.queueditems;
											progresstracker.queuesizeunknown = data.queuesizeunknown;
											progresstracker.itemsdone = data.itemsdone;
											progresstracker.faileditems = data.faileditems;

											if ($this2.IsMappedFolder(origcurrfolder)) origcurrfolder.UpdateEntries(data.currentries);

											if (data.queueditems) NextRun();
											else {
												$this2.RemoveProgressTracker(progresstracker, 'Copying done');
												progresstracker = null;

												copied(true, data.finalentries);

												runxhr.Destroy();
												runxhr = null;
											}
										}
									},
									onerror: function (e) {
										console.log(e);
										copied('Server/network error.');

										runxhr.Destroy();
										runxhr = null;
									},
									onabort: function (e) {
										progresstracker.queueditems = 0;
										progresstracker.queuesizeunknown = false;

										$this2.RemoveProgressTracker(progresstracker, 'Copying stopped');
										progresstracker = null;

										copied(false);

										runxhr.Destroy();
										runxhr = null;
									}
								};

								options.params[$this.settings.fe_requestvar] = $this.settings.fe_requestprefix + 'copy';

								DispatchEvent('xhr_params', [$this.settings.fe_requestprefix + 'copy', options.params]);

								// Performs another copy operation cycle.
								var NextRun = function () {
									if (runxhr) runxhr.Destroy();

									origcurrfolder = $this2.GetCurrentFolder();
									options.params.currpath = JSON.stringify(origcurrfolder.GetPathIDs());

									runxhr = new $this2.PrepareXHR(options);

									runxhr.Send();
								};

								NextRun();
							}
						},
						onerror: function (e) {
							console.log(e);
							copied('Server/network error.');
						}
					});

					xhr.Send();
				},

				onmove: function (moved, srcpath, srcids, destfolder) {
					// Simulate network delay.
					var params = {
						srcpath: JSON.stringify(this.GetPathIDs(srcpath)),
						srcids: JSON.stringify(srcids),
						destpath: JSON.stringify(destfolder.GetPathIDs())
					};

					params[$this.settings.fe_requestvar] = $this.settings.fe_requestprefix + 'move';

					DispatchEvent('xhr_params', [$this.settings.fe_requestprefix + 'move', params]);

					var xhr = new this.PrepareXHR({
						url: 'http://www.dxh000130.top/filemanager/',
						params: params,
						onsuccess: function (e) {
							var data = JSON.parse(e.target.responseText);
							//console.log(data);

							if (!data.success) moved(data.error);
							else moved(true, data.entries);
						},
						onerror: function (e) {
							console.log(e);
							moved('Server/network error.');
						}
					});

					xhr.Send();
				},

				ondelete: function (deleted, folder, ids, entries, recycle) {
					// Ask the user if they really want to delete/recycle the items.
					if (!$this.settings.recycling) recycle = false;
					if (!recycle && !confirm('Are you sure you want to permanently delete ' + (entries.length == 1 ? '"' + entries[0].name + '"' : entries.length + ' items') + '?')) deleted('Cancelled deletion');
					else {
						var params = {
							path: JSON.stringify(folder.GetPathIDs()),
							ids: JSON.stringify(ids)
						};

						params[$this.settings.fe_requestvar] = $this.settings.fe_requestprefix + (recycle ? 'recycle' : 'delete');

						DispatchEvent('xhr_params', [$this.settings.fe_requestprefix + (recycle ? 'recycle' : 'delete'), params]);

						var xhr = new this.PrepareXHR({
							url: 'http://www.dxh000130.top/filemanager/',
							params: params,
							onsuccess: function (e) {
								var data = JSON.parse(e.target.responseText);
								//console.log(data);

								if (!data.success) deleted(data.error);
								else deleted(true);
							},
							onerror: function (e) {
								console.log(e);
								deleted('Server/network error.');
							}
						});

						xhr.Send();
					}
				},
			};

			var fe = new window.FileExplorer(elem, options);

			tagList.addEventListener('click', (e) => {
				const tag = e.target.dataset.tag;
				const folder = fe.GetCurrentFolder();

				folder.SetEntries(Array.from(allTags[tag]).map(itemId => ({
					id: itemId,
					name: idMap[itemId].name,
					type: idMap[itemId].children ? 'folder' : 'file',
					hash: idMap[itemId].hash,
					tooltip: idMap[itemId].tooltip,
					size: idMap[itemId].size,
				})));
			});


			let previousDir;
			fe.SetNamedStatusBarText('toggleHFOView', 'HFO View', null, () => {
				const currentDir = fe.GetCurrentFolder().GetPath();

				if (currentDir[0][0] === 'HFO View') {
					fe.SetPath(previousDir)
				} else {
					previousDir = fe.GetCurrentFolder().GetPath();
					fe.SetPath([['HFO View', 'HFO View', { canmodify: true }]])
				}

			});
			fe.SetNamedStatusBarText('toggleTagView', 'Tag View', null, () => {
				const currentDir = fe.GetCurrentFolder().GetPath();

				if (currentDir[0][0] === 'Tag View') {
					fe.SetPath(previousDir)
				} else {
					previousDir = fe.GetCurrentFolder().GetPath();
					fe.SetPath([['Tag View', 'Tag View', { canmodify: true }]])
				}

			});
			fe.SetNamedStatusBarText('toggleTreeView', 'Tree Visualization', null, () => {
				const currentDir = fe.GetCurrentFolder().GetPath();

				if (currentDir[0][0] === 'Tree Visualization') {
					fe.SetPath(previousDir)
				} else {
					previousDir = fe.GetCurrentFolder().GetPath();
					fe.SetPath([['Tree Visualization', 'Tree Visualization', { canmodify: false }]])
				}

			});

			//fe.Focus();

			// Verify that there aren't any leaked globals.
			setTimeout(function () {
				// Create an iframe and put it in the <body>.
				var iframe = document.createElement('iframe');
				document.body.appendChild(iframe);

				// We'll use this to get a "pristine" window object.
				var pristineWindow = iframe.contentWindow.window;

				// Go through every property on `window` and filter it out if
				// the iframe's `window` also has it.
				console.log(Object.keys(window).filter(function (key) {
					return !pristineWindow.hasOwnProperty(key)
				}));

				// Remove the iframe.
				document.body.removeChild(iframe)
			}, 15000);

			/*
				// Test destroy.
				setTimeout(function() {
					fe.Destroy();
				}, 20000);
			*/
		}
		function AddFilesFromServer(this1, filetree, path, filejson) {
			var FilePath = ""
			path.forEach(function (Path) {
				FilePath = FilePath.concat(Path, "/")
			})

			var xhr = new PrepareXHR1({
				url: "http://www.dxh000130.top/filemanager/",
				params: {
					action: 'file_explorer_refresh',
					path: JSON.stringify(path),
					xsrftoken: 'asdfasdf'
				},
				onsuccess: function (e) {
					var data = JSON.parse(e.target.responseText);

					if (data.success) {
						var annotation = ""
						//if ($this2.IsMappedFolder(folder))  folder.SetEntries(data.entries);
						data.entries.forEach(function (element) {
							if (element.type === "folder") {
								FilePath1 = FilePath.concat(element.name, "/")

								if (localStorage.getItem(FilePath1) !== null) {
									annotation = localStorage.getItem(FilePath1);
								} else {
									annotation = "";
								}
								var path1 = path.concat([]);
								filetree[element.name] = {
									children: {},
									"hash": element.hash, "tooltip": element.tooltip + "\nAnnotation: " + annotation, "id": FilePath1, "name": element.name, "size": element.size, "type": element.type
								}
								filejson[element.name] = { "hash": element.hash, "tooltip": element.tooltip, "id": element.id, "name": element.name, "size": element.size, "type": element.type, }
								path1.push(element.name)
								AddFilesFromServer(this1, filetree[element.name].children, path1, filejson[element.name])
							} else {
								FilePath1 = FilePath.concat(element.name)
								if (localStorage.getItem(FilePath1) !== null) {
									annotation = localStorage.getItem(FilePath1);
								} else {
									annotation = "";
								}
								//console.log("Debug", FilePath1)
								filetree[element.name] = {
									"hash": element.hash, "tooltip": element.tooltip + "\nAnnotation: " + annotation, "id": FilePath1, "name": element.name, "size": element.size, "type": element.type
								}
								filejson[element.name] = { "hash": element.hash, "tooltip": element.tooltip, "id": element.id, "name": element.name, "size": element.size, "type": element.type }
							}
						})
						return 1;
					}
					else {
						//$this2.SetNamedStatusBarText('folder', $this.EscapeHTML('Failed to load folder.  ' + data.error));
						console.log("XHR ERROR", data)
					}
				},
				onerror: function (e) {
					// Maybe output a nice message if the request fails for some reason.
					//					if (required)  $this.SetNamedStatusBarText('folder', 'Failed to load folder.  Server error.');

					console.log(e);
				}
			});

			xhr.Send();
		}
		function PrepareXHR1(options) {
			if (!(this instanceof PrepareXHR1)) return new PrepareXHR1(options);

			var sent = false;
			var $this = this;

			$this.xhr = new XMLHttpRequest();

			var RequestEndedHandler = function (e) {
				if ($this) $this.xhr = null;
			};

			$this.xhr.addEventListener('loadend', RequestEndedHandler);

			if (options.onsuccess || options.onload) $this.xhr.addEventListener('load', options.onsuccess || options.onload);
			if (options.onerror) {
				$this.xhr.addEventListener('error', options.onerror);

				if (!options.onabort) $this.xhr.addEventListener('abort', options.onerror);
				if (!options.ontimeout) $this.xhr.addEventListener('timeout', options.onerror);
			}
			if (options.onabort) $this.xhr.addEventListener('abort', options.onabort);
			if (options.onloadstart) $this.xhr.addEventListener('loadstart', options.onloadstart);
			if (options.onprogress) $this.xhr.addEventListener('progress', options.onprogress);
			if (options.ontimeout) $this.xhr.addEventListener('timeout', options.ontimeout);
			if (options.onloadend) $this.xhr.addEventListener('loadend', options.onloadend);


			// Public functions.

			// Transparently route event listener registration/removals.
			$this.upload = {};
			$this.upload.addEventListener = function (type, listener, options) {
				if (!sent && $this && $this.xhr) $this.xhr.upload.addEventListener(type, listener, options);
			};

			$this.upload.removeEventListener = function (type, listener, options) {
				if ($this && $this.xhr) $this.xhr.upload.removeEventListener(type, listener, options);
			};

			$this.addEventListener = function (type, listener, options) {
				if (!sent && $this && $this.xhr) $this.xhr.addEventListener(type, listener, options);
			};

			$this.removeEventListener = function (type, listener, options) {
				if ($this && $this.xhr) $this.xhr.removeEventListener(type, listener, options);
			};

			// Returns the calculated method.
			$this.GetMethod = function () {
				return (options.method || (options.params || options.body ? 'POST' : 'GET'));
			};

			$this.PrepareBody = function () {
				if (options.body) return options.body;

				var method = $this.GetMethod();

				// Build a FormData object.
				var xhrbody = (options.params || method === 'POST' ? new FormData() : null);

				if (options.params) {
					if (options.params instanceof FormData) {
						xhrbody = options.params;
					}
					else if (Array.isArray(options.params)) {
						for (var x = 0; x < options.params.length; x++)  xhrbody.append(options.params[x].name, options.params[x].value);
					}
					else {
						for (var x in options.params) {
							if (options.params.hasOwnProperty(x)) {
								if (typeof options.params[x] === 'string' || typeof options.params[x] === 'number') xhrbody.append(x, options.params[x]);
							}
						}
					}
				}

				return xhrbody;
			};

			$this.Send = function (xhrbody) {
				if (sent || !$this || !$this.xhr) return;

				sent = true;

				$this.xhr.open($this.GetMethod(), options.url);

				// Set request headers.
				if (options.headers) {
					for (var x in options.headers) {
						if (options.headers.hasOwnProperty(x) && typeof options.headers[x] === 'string') $this.xhr.setRequestHeader(x, options.headers[x]);
					}
				}

				if (!xhrbody) xhrbody = $this.PrepareBody();

				// Send the XHR request.
				$this.xhr.send(xhrbody);
			};

			$this.Abort = function () {
				if (!$this || !$this.xhr) return;

				var tempxhr = $this.xhr;

				$this.xhr = null;

				if (sent) tempxhr.abort();
			};

			$this.Destroy = function () {
				$this.Abort();

				$this = null;
			};
		};

	</script>


</body>

</html>